//  ====================================================================================================================================================
//      Calculations
//  ====================================================================================================================================================


vwma(series int length, series float source = hlc3, simple float volume_default = na) =>
    var     _sum    = 0.0
    var     _vol    = 0.0
    float   _datum  = na

    _volume = volume
    if na(_volume) and not na(volume_default)
        _volume := volume_default

    if not na(source) and not na(_volume)
        _vol     += _volume
        _datum   := source * _volume
        _sum     += _datum
    else
        _volume := na

    _volume_start   =   _volume[length]
    _datum_start    =   _datum[length]
    if not na(_volume_start)
        _vol -= _volume_start
    if not na(_datum_start)
        _sum -= _datum_start

    _vol == 0 ? na : _sum / _vol

cma(series int length, series float source = close, simple float C = 1, simple bool compound = false) =>
    var float   result      = na
    float       sum         = 0.0
    float       weight      = 1.0
    float       weightTotal = 0.0

    for m = 1 to length
        s = source[length - m]
        if not na(s)
            sum := sum + s * weight
            weightTotal += weight
            if compound
                weight *= 1 + C
            else
                weight += C

    prev = result[length]
    if na(prev)
        result := sum / weightTotal
    else
        result := (prev + sum) / (weightTotal + 1)

ema(series int length, series float source = close) =>
    var float alpha = 2 / (length + 1)
    var float a1 = 1 - alpha
    var float s = na
    var float ema = na
    if not na(source)
        s := source
    ema := alpha * s + a1 * nz(ema)

wma(series int length, series float source = close, simple int startingWeight = 1) =>
    float   sum = 0.0
    float   total = 0
    int     last = length - 1
    for i = 0 to last
        s = source[i]
        if not na(s)
            m = last - i + startingWeight
            total += m
            sum += s * m
    total == 0 ? na : sum / total

vawma(series int length, series float source = hlc3, simple float volumeDefault = na, simple int startingWeight = 1) =>
    float   sum = 0.0
    float   vol = 0.0
    int     last = length - 1
    for i = 0 to last
        s = source[i]
        v = volume[i]
        if na(v) and not na(volumeDefault)
            v := volumeDefault
        if not na(s) and not na(v)
            m = last - i + startingWeight
            v *= m
            vol += v
            sum += s * v
    vol == 0 ? na : sum / vol

ma(series string ma, series int length, series float source = na) =>
    switch ma
        "smma"  =>  smma(   length, na(source) ? close  : source)
        "zlema" =>  zlema(  length, na(source) ? hlc3   : source)
        "WMA"   =>  wma(    length, na(source) ? close  : source)
        "EMA"   =>  ema(    length, na(source) ? close  : source)
        "VWMA"  =>  vwma(   length, na(source) ? hlc3   : source)
        "VAWMA" =>  vawma(  length, na(source) ? hlc3   : source)
        "CMA"   =>  cma(    length, na(source) ? close  : source)
        "SMA"   =>  ta.sma(na(source) ? close  : source, length)
        =>          ta.sma(na(source) ? close  : source, length)

stdev(series float source, series int length, simple bool useWma = false, simple int smoothing = 0) =>
    prev = source[1]
    mean = useWma ? wma(length, prev) : ta.sma(prev, length)
    diff = prev - mean
    diff2 = diff * diff
    variance = useWma ? wma(length, diff2) : ta.sma(diff2, length)
    stdev = math.sqrt(variance)
    if smoothing > 0
        mean    := ta.sma(mean, smoothing + 1)
        stdev   := ta.sma(stdev, smoothing + 1)
    [mean, stdev]

outliners(series float source, series int length, series float maxDeviation = 4, simple bool useWma = false, simple int smoothing = 0) =>
    [mean, stdev] = stdev(source, length, useWma, smoothing)
    dev = stdev * maxDeviation
    source > mean + dev or source < mean - dev ? na : source

atr(series string ma, series int length, series float maxDeviation) =>
    _outliners  =   outliners(ta.tr, length, maxDeviation)
    trCleaned   =   maxDeviation == 0 ? ta.tr : _outliners
    ma(ma, length, trCleaned)


//  ====================================================================================================================================================
//      Improved SuperTrend support
//          Source:
//          https://www.tradingview.com/script/smXJk7s5-SuperTrend/
//  ====================================================================================================================================================

type SuperTrend
    int     trend
    float   up
    float   down
    int     hits
    bool    warning
    bool    reversal

_super_trend_2(series float multiple, series float highs, series float lows, series float atr, series int closed_bars = 0) =>
    _up     =   lows    -   (multiple   *   atr)
    _up1    =   nz(_up[1], _up)
    _up     :=  lows[1] > _up1 ? math.max(_up, _up1) : _up

    _down   =   highs   +   (multiple   *   atr)
    _down1  =   nz(_down[1], _down)
    _down   :=  highs[1] < _down1 ? math.min(_down, _down1) : _down

    var _last_up        = _up1
    var _last_down      = _down1
    var _trend          = 0
    var _confirmation   = 0
    var _unconfirmed    = 0

    if(_trend != +1 and lows > _last_down)
        _trend := +1

    else if(_trend != -1 and highs < _last_up)
        _trend := -1

    else if(_trend != +1 and highs > _last_down)
        _unconfirmed += 1
        if(_confirmation < closed_bars and close[1] > _last_down)
            _confirmation += 1
        if(_confirmation >= closed_bars)
            _trend := +1

    else if(_trend != -1 and lows < _last_up)
        _unconfirmed += 1
        if(_confirmation < closed_bars and close[1] < _last_up)
            _confirmation += 1
        if(_confirmation >= closed_bars)
            _trend := -1

    if(_trend[1] != _trend)
        _last_up        := _up1
        _last_down      := _down1
        _confirmation   := 0
        _unconfirmed    := 0
    else
        _last_up    := _trend ==+1 ? math.max(_last_up,     _up1)   : _up1
        _last_down  := _trend ==-1 ? math.min(_last_down,   _down1) : _down1
        if(_trend==+1 and _down1 > _down1[1] or _trend == -1 and _up1 < _up1[1])
            _confirmation   := 0
            _unconfirmed    := 0

    SuperTrend.new(_trend, _last_up, _last_down, _unconfirmed, _unconfirmed[1] == 0 and _unconfirmed > 0, _trend != _trend[1])

_super_trend_2(series float multiple, series int length, simple string mode = "WMA", series int closeBars = 0, series float maxDeviation = 0) =>
    _super_trend_2(multiple, high, low, atr(mode, length, maxDeviation), closeBars)

use_super_trend2(Contexts contexts) =>
    var Context	_context	    =	context_create("super-trend2")
    float       _i_multiplier   =   3.0
    int         _i_length       =   120
    int         _i_closed_bars  =   2
    SuperTrend  _trend    = _super_trend_2(_i_multiplier, _i_length, "VAWMA", _i_closed_bars, 0)

    use_context(contexts, _context)


//  ====================================================================================================================================================
//      Track current trends / structure levels
//			Because this indicator is somehow under development, I'll keep it here.
//  ====================================================================================================================================================

type Trend
	int		start
	int		index
	float	price
	float	close
	int		count

type Test
	Level	level
	int[]	index
	int		count

trend_create() =>
	Trend.new(na, na, na, na, 0)

use_trends(Contexts[] candles, Contexts contexts) =>
	var Context	_context	=	context_create("trends")

	float	_factor		=	contexts_get_float(	contexts, "ctx", "trends.factor")
	int		_touches	=	contexts_get_int(	contexts, "ctx", "trends.touches")
	int		_count		=	contexts_get_int(	contexts, "ctx", "trends.count")
	int		_trend		=	contexts_get_int(	contexts, "ctx", "trends.trend")

	//	Currently tested set of all candles
	Test[]	_tests		=	array.new<Test>()
	Test	_test		=	na

	Trend	_trend_up	=	trend_create()
	Trend	_trend_down	=	trend_create()

	//	Count number of touches for lows & highs
	for __candle in candles
		_up				=	contexts_get_bool(__candle, "candle", "up")
		_down			=	contexts_get_bool(__candle, "candle", "down")

		_bottom			=	contexts_get_float(__candle, "candle", "bottom")
		_top			=	contexts_get_float(__candle, "candle", "top")

		_index			=	contexts_get_int(__candle, "candle", "index")
		_low_level		=	level("low",	_bottom		-	_factor,		_factor)
		_high_level		=	level("high",	_top		+	_factor,		_factor)

		if _up
			_trend_up.start		:=	na(_trend_up.start) ? _index	: _trend_up.start
			_trend_up.price		:=	na(_trend_up.price) ? _bottom	: _trend_up.price
			_trend_up.index		:=	_index
			_trend_up.close		:=	_bottom
			_trend_up.count		+=	1

			_trend_down:=	trend_create()

		if _down
			_trend_down.start	:=	na(_trend_down.start) ? _index	: _trend_down.start
			_trend_down.price	:=	na(_trend_down.price) ? _bottom	: _trend_down.price
			_trend_down.index	:=	_index
			_trend_down.close	:=	_bottom
			_trend_down.count	+=	1

			_trend_up:=		trend_create()

		if _tests.size() == 0
			_tests.push(Test.new(_low_level,	array.from(_index), 0))
			_tests.push(Test.new(_high_level,	array.from(_index), 0))

		_found	=	false

		for __test in _tests
			if (level_inside(__test.level, _bottom) or level_inside(__test.level, _top)) and (_index - __test.index.last()) >= _count
				_found			:=	true
				__test.count	+=	1
				__test.index.push(_index)

		if not _found
			_tests.push(Test.new(_low_level,	array.from(_index), 1))
			_tests.push(Test.new(_high_level,	array.from(_index), 1))

	for __test in _tests
		if __test.count >= _touches and na(_test)
			_test:=	__test
			continue

		if na(_test)
			continue

		if __test.count >= _touches and __test.index.last() > _test.index.last()
			_test:=	__test

	context_set(_context,	"up",			_trend_up.count >= _trend)
	context_set(_context,	"up.count",		_trend_up.count)
	context_set(_context,	"down",			_trend_down.count >= _trend)
	context_set(_context,	"down.count",	_trend_down.count)

	context_set(_context,	"level",		na(_test) ? level() : _test.level)

	//	Render
	if not na(_test)
		level_render("trend.low", _test.level, _test.index.first(), na, color.yellow)

	var	line	_trend_up_line		=	na
	var	line	_trend_down_line	=	na

	line.delete(_trend_up_line)
	line.delete(_trend_down_line)

	if _trend_up.count	>= _trend
		_trend_up_line		:=	line.new(_trend_up.start,	_trend_up.price,	_trend_up.index,		_trend_up.close,	extend = extend.both, color = color.green)

	if _trend_down.count	>= _trend
		_trend_down_line	:=	line.new(_trend_down.start,	_trend_down.price,	_trend_down.index,		_trend_down.close,	extend = extend.both, color = color.red)

	use_context(contexts, _context)
