// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © marekhanzal

//@version=5

// @description PiPi Script Execution Engine
library("PiPi2_Script", overlay = true)

//  ====================================================================================================================================================
//      Dependencies
//  ====================================================================================================================================================

import marekhanzal/PiPi2_Context/4	as ctx
import marekhanzal/PiPi2_Pattern/5	as pattern
import marekhanzal/PiPi2_Toolbox/2	as toolbox

//  ====================================================================================================================================================
//      Types
//  ====================================================================================================================================================

//	@type				Match tracking of the given pattern
//	@field	strict		Matching mode: strict - consecutive candles must match; non-strict, candles are checked continually
//	@field	priority	When multiple matches win, one with highest priority will be executed
//	@field	pattern		Array index of pattern (in script, or whatever is used to store patterns) this match belongs to
//	@field	rule		Index to current pattern rule
//	@field	count		Count of successfull matches
//	@field	length		Current match "runtime" - number of bars check runs
//	@field	track		Track current state of match; if this one falls "false", pattern matching failed and this Match should reset
//	@field	match		Match status; if true, pattern's action should be executed + this state reset
export type Match
	bool	strict
	float	priority
	int		pattern
	int		rule
	int		count
	int		length
	bool	track
	bool	match

//  @type               Action can create a mark (label)
//  @field  title       Text to display
//  @field  color       Mark color
export type Mark
    string              title
    string              hint
    string              color
    string              text_color
    string              position

//	@type				When a pattern matches, execute an action
//	@field	mutator	Set values
//	@field	profit		Set profit (does not execute a trade)
//	@field	loss		Set loss (does not execute a trade)
//	@field	order		> 0, long, < 0 short, everything else - nothing
//  @field  mark        Action may display mark (label)
export type Action
	string				hint
	ctx.Mutator[]		mutator
	ctx.Math			profit
	ctx.Math			loss
    string[]            size
	int					order
	bool				close
    Mark                mark

//	@type				Pattern used to match multiple candles
//	@field	priority	Higher pattern priority wins, when there are multiple winning Patterns
//	@field	strict		Strict means all candles must be next to each other; non-strict - pattern is checked on the fly, last matching candle commits true
//	@field	length		When non-strict pattern is enabled, length defines how many bars to wait to finish a pattern before pattern is considered broken
//	@field	enabled		Feature for the user to enable/disable pattern when trying different appraches
//	@field	candle		Array of candle rules
//	@field	action		Action being taken when pattern is matched
export type Pattern
	string				name
	int					priority
	bool				strict
	int					length
	bool				enabled
	pattern.Candle[]	candle
	Action				action

//	@type				Startup part of the script
//	@field	set_value	Those values will be set into the context(s)
export type Init
	int					priority
	bool				long
	bool				short
	ctx.Mutator[]		mutator

//	@type				All the candle matching stuff
//	@field	init		Startup part of script; should be called *exactly* once
//	@field	pattern		Patterns used to match candles
export type Script
	Init				init
	Pattern[]			pattern

//	---		Factory methods

export match_create(bool strict, float priority, int pattern)		=>	Match.new(strict, priority, pattern, 0, 0, 0, false, na)
export mark_create()												=>  Mark.new(na, na, "blue", "white", "above")
export action_create()												=>  Action.new(na, array.new<ctx.Mutator>(), na, na, array.from("2"), 0, false, na)
export pattern_create()												=>  Pattern.new(na, 0, false, 30, true, array.new<pattern.Candle>(), action_create())
export init_create()												=>  Init.new(0, true, true, array.new<ctx.Mutator>())
export script_create()												=>  Script.new(init_create(), array.new<Pattern>())

//  ====================================================================================================================================================
//      Utils
//  ====================================================================================================================================================

match_reset(Match match)	=>
	match.rule:=	0
	match.count:=	0
	match.length:=	0
	match.track:=	false
	match.match:=	na

//  ====================================================================================================================================================
//      Individual handlers
//  ====================================================================================================================================================

//	@function	Runs initialization part of a script
export eval_init(ctx.Contexts contexts, Script script) =>
	ctx.contexts_mutate(contexts, script.init.mutator)

//  ---     Script: Action - Order Entry
//          This is internal function handling TradingView Strategy Tester entries

//	@function	This function executes a trade, if it's specified in the action
eval_trade(ctx.Contexts contexts, Init init, Pattern pattern) =>
	var box	_box	=	na
    Action  _action =   pattern.action
    string  _hint   =   na(_action.hint) ? pattern.name : _action.hint

	if _action.order != 0
		_is_session	=	ctx.contexts_get_bool(contexts, "session", "open", true)
		_profit		=	na(_action.profit)	? na : ctx.contexts_math(contexts,  _action.profit)
		_loss		=	na(_action.loss)	? na : ctx.contexts_math(contexts,  _action.loss)
        _size       =   ctx.contexts_get_float(contexts, _action.size)

		if _is_session and not bool(strategy.position_size)
			_entry = false
			_hint_profit	= na(_hint) ? "TP" : _hint + ": TP"
			_hint_loss		= na(_hint) ? "SL" : _hint + ": SL"

			if _action.order > 0 and init.long
				_entry:= true
				strategy.entry("long", direction = strategy.long, comment = _hint, qty = _size)
				strategy.exit("long-limit",  from_entry = "long", limit = _profit, stop = _loss, comment_loss = _hint_loss, comment_profit = _hint_profit)
			else if _action.order < 0 and init.short
				_entry:= true
				strategy.entry("short", direction = strategy.short, comment = _hint, qty = _size)
				strategy.exit("short-limit",  from_entry = "short", limit = _profit, stop = _loss, comment_loss = _hint_loss, comment_profit = _hint_profit)

			if _entry
				ctx.contexts_set(contexts,	"trade", "entry",	true)

                ctx.contexts_set(contexts,	"ctx",  "buy",      _action.order > 0)
				ctx.contexts_set(contexts,	"ctx",  "sell",     _action.order < 0)

				ctx.contexts_set(contexts,	"trade", "long",	_action.order > 0)
				ctx.contexts_set(contexts,	"trade", "short",	_action.order < 0)
				ctx.contexts_set(contexts,	"trade", "profit",	_profit)
				ctx.contexts_set(contexts,	"trade", "loss",	_loss)

				//	Reset trade length to zero
				ctx.contexts_counter(contexts,	"trade", "length",	na)

				alert(_hint)

	if bool(strategy.position_size) and _action.close
		ctx.contexts_set(contexts,	"trade", "closed",	true)
		strategy.close_all("CBA")

//	@function			Handles pattern detection; it tracks pattern state during individual bars for low resource usage
//	@param	contexts	Contexts used for evaluation
//	@param	patterns	Patterns you want to track and detect
eval_pattern(ctx.Contexts contexts, Init init, Pattern[] patterns) =>
	var Match[]		_matches	=	array.new<Match>()
	Pattern			_pattern	=	na

	if toolbox.use_init()
		//	Prepare array of matches with default state; this must be run only once on the first bar
		for __index = 0 to (patterns.size() == 0 ? na : patterns.size() - 1)
			__pattern	=	patterns.get(__index)
			if __pattern.enabled and __pattern.priority >= init.priority
				_matches.push(match_create(__pattern.strict, __pattern.priority, __index))

	for __match in _matches
		__pattern	=	patterns.get(__match.pattern)
		__rule		=	__pattern.candle.get(__match.rule)

		if pattern.match(contexts, __rule)
			__match.count	+=	1
			__match.track	:=	true
			if not __match.strict
				__match.rule	+=	1

		else if __match.strict
			__match.track:=		false
			__match.match:=		false

		if __match.strict
			__match.rule	+=	1

		__match.length	+=	1

		if __match.rule >= __pattern.candle.size()
			__match.match:=		__match.track

		if not __match.strict
			if __match.count >= __pattern.candle.size()
				__match.match:=		true

			if __match.length >= __pattern.length
				__match.match:=	__match.track and __match.count >= __pattern.candle.size()

	for __match in _matches
		if __match.match
			__current_pattern = patterns.get(__match.pattern)

			if na(_pattern)
				_pattern:=	__current_pattern

			if __current_pattern.priority >= _pattern.priority
				_pattern:=	__current_pattern

			match_reset(__match)

		if not na(__match.match) and not __match.match
			match_reset(__match)

	_pattern

eval_mark(Mark mark) =>
	if not na(mark)
        label.new(bar_index,
         high,
         xloc		= xloc.bar_index,
         style		= toolbox.style_yloc_of(mark.position),
         yloc		= toolbox.yloc_of(mark.position),
         text		= mark.title,
         tooltip	= mark.hint,
         textcolor	= toolbox.color_of(mark.text_color),
         color		= toolbox.color_of(mark.color)
         )

eval_action(ctx.Contexts contexts, Init init, Pattern pattern) =>
	if not na(pattern)
		ctx.contexts_mutate	(contexts, pattern.action.mutator)
		eval_trade			(contexts, init, pattern)
		eval_mark			(pattern.action.mark)

	pattern

//	@function				Runs the scrpt, tracks patterns per-bar, and do whatever a script should do, yaay!
//	@param		contexts	Current contexts from all provides script may access
//	@param		script		Script itself; doesn't matter, where it comes from
export eval(ctx.Contexts contexts, Script script) =>
	// Reset default states
	ctx.contexts_set(contexts,	"trade", "entry",	false)
	ctx.contexts_set(contexts,	"ctx",  "buy",      false)
	ctx.contexts_set(contexts,	"ctx",  "sell",     false)

	eval_action(contexts, script.init, eval_pattern(contexts, script.init, script.pattern))

	script
